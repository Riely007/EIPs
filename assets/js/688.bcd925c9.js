(window.webpackJsonp=window.webpackJsonp||[]).push([[688],{1110:function(t,e,a){"use strict";a.r(e);var c=a(46),i=Object(c.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[t._v("#")]),t._v(" Abstract")]),t._v(" "),a("p",[t._v("This is a proposal to add a new opcode, "),a("code",[t._v("CALLDEPTH")]),t._v(". The "),a("code",[t._v("CALLDEPTH")]),t._v(" opcode would return the remaining available call stack depth.")]),t._v(" "),a("h1",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[t._v("#")]),t._v(" Motivation")]),t._v(" "),a("p",[t._v("There is a limit specifying how deep contracts can call other contracts; the call stack. The limit is currently "),a("code",[t._v("256")]),t._v(". If a contract invokes another contract (either via "),a("code",[t._v("CALL")]),t._v(" or "),a("code",[t._v("CALLCODE")]),t._v("), the operation will fail if the call stack depth limit has been reached.")]),t._v(" "),a("p",[t._v('This behaviour makes it possible to subject a contract to a "call stack attack" [1]. In such an attack, an attacker first creates a suitable depth of the stack, e.g. by recursive calls. After this step, the attacker invokes the targeted contract. If the targeted calls another contract, that call will fail. If the return value is not properly checked to see if the call was successful, the consequences could be damaging.')]),t._v(" "),a("p",[t._v("Example:")]),t._v(" "),a("ol",[a("li",[t._v("Contract "),a("code",[t._v("A")]),t._v(" wants to be invoked regularly, and pays Ether to the invoker in every block.")]),t._v(" "),a("li",[t._v("When contract "),a("code",[t._v("A")]),t._v(" is invoked, it calls contracts "),a("code",[t._v("B")]),t._v(" and "),a("code",[t._v("C")]),t._v(", which consumes a lot of gas. After invocation, contract "),a("code",[t._v("A")]),t._v(" pays Ether to the caller.")]),t._v(" "),a("li",[t._v("Malicious user "),a("code",[t._v("X")]),t._v(" ensures that the stack depth is shallow before invoking A. Both calls to "),a("code",[t._v("B")]),t._v(" and "),a("code",[t._v("C")]),t._v(" fail, but "),a("code",[t._v("X")]),t._v(" can still collect the reward.")])]),t._v(" "),a("p",[t._v("It is possible to defend against this in two ways:")]),t._v(" "),a("ol",[a("li",[t._v("Check return value after invocation.")]),t._v(" "),a("li",[t._v("Check call stack depth experimentally. A library [2] by Piper Merriam exists for this purpose. This method is quite costly in gas.")])]),t._v(" "),a("p",[t._v("[1] a.k.a \"shallow stack attack\" and \"stack attack\". However, to be precise, the word ''stack'' has a different meaning within the EVM, and is not to be confused with the ''call stack''.")]),t._v(" "),a("p",[t._v("[2] https://github.com/pipermerriam/ethereum-stack-depth-lib")]),t._v(" "),a("h1",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[t._v("#")]),t._v(" Specification")]),t._v(" "),a("p",[t._v("The opcode "),a("code",[t._v("CALLDEPTH")]),t._v(" should return the remaining call stack depth. A value of "),a("code",[t._v("0")]),t._v(" means that the call stack is exhausted, and no further calls can be made.")]),t._v(" "),a("h1",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[t._v("#")]),t._v(" Rationale")]),t._v(" "),a("p",[t._v("The actual call stack depth, as well as the call stack depth limit, are present in the EVM during execution, but just not available within the EVM. The implementation should be fairly simple and would provide a cheap and way to protect against call stack attacks.")]),t._v(" "),a("h1",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[t._v("#")]),t._v(" Implementation")]),t._v(" "),a("p",[t._v("Not implemented.")])])}),[],!1,null,null,null);e.default=i.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[567],{983:function(e,t,a){"use strict";a.r(t);var i=a(46),o=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/zh/eip-155.html"}},[e._v("EIP-155")]),e._v(" proposes to use the chain ID to prevent the replay of transactions between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling off-chain message signatures, especially for Layer 2 signature schemes using "),a("RouterLink",{attrs:{to:"/zh/eip-712.html"}},[e._v("EIP-712")]),e._v(".")],1),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/zh/eip-1344.html"}},[e._v("EIP-1344")]),e._v(" is attempting to solve this by giving smart contract access to the tip of the chainID history. This is insuficient as such value is changing. Hence why EIP-1344 describes a contract based solution to work around the problem. It would be better to solve it in a simpler, cheaper and safer manner, removing the potential risk of misuse present in EIP-1344. Furthermore EIP-1344 can't protect replay properly for minority-led hardfork as the caching system cannot guarantee accuracy of the blockNumber at which the new chainID has been introduced.")],1),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/zh/eip-1959.html"}},[e._v("EIP-1959")]),e._v(" solves the issue of EIP-1344 but do not attempt to protect from minority-led hardfork as mentioned in the rationale. We consider this a mistake, since it remove some freedom to fork. We consider that all fork should be given equal oportunities. And while there will always be issues we can't solve for the majority that ignore a particular fork, "),a("strong",[e._v("users that decide to use both the minority-fork and the majority-chain should be protected from replay without having to wait for the majority chain to update its chainID.")])],1),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("Adds a new precompile which uses 2 argument : a 32 bytes value that represent the chainID to test and a 32 bytes value representing the blockNumber at which the chainID is tested. It return 0x1  if the chainID is valid at the specific blockNumber, 0x0 otherwise. Note that chainID are considered valid up to the blockNumber at which they are replaced. So they are valid for every blockNumber past their replacement.")]),e._v(" "),a("p",[e._v("The operation will costs no more than "),a("code",[e._v("G_blockhash")]),e._v(" + "),a("code",[e._v("G_verylow")]),e._v(" to execute. This could be lower as chainID are only introduced during hardfork.")]),e._v(" "),a("p",[e._v("The cost of the operation might need to be adjusted later as the number of chainID in the history of the chain grows.")]),e._v(" "),a("p",[e._v("Note though that the alternative to keep track of old chainID is to implement a smart contract based caching solution as EIP-1344 proposes comes with an overall higher gas cost and exhibit issues for minority-led hardfork (see Rationale section below). As such the gas cost is simply a necessary cost for the feature.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("The rationale at EIP-1959 applies here as well too :")]),e._v(" "),a("ul",[a("li",[e._v("An opcode is better than a caching system for past chainID, It is cheaper, safer and do not include gaps.")]),e._v(" "),a("li",[e._v("Direct access to the latest chainID is dangerous since it make it easy for contract to use it as a replay protection mechanism while preventing otherwise valid old messages to be valid after a fork that change the chainID. This can have disastrous consequences on users.")]),e._v(" "),a("li",[e._v("all off-chain messaged signed before a fork should be valid across all side of the fork.")])]),e._v(" "),a("p",[e._v("The only difference is that this current proposal propose a solution to protect hardfork led by a minority.")]),e._v(" "),a("p",[e._v("To summarize there is 2 possible fork scenario :")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("The majority decide to make an hardfork but a minority disagree with it (ETC is such example). The fork is planned for block X. If the majority is not taking any action to automate the process of assigning a different chainID for both, the minority has plenty of time to plan for a chainID upgrade to happen at that same block X. Now if they do not do it, their users will face the problem that their messages will be replayable on the majority chain (Note that this is not true the other way around as we assume the majority decided to change the chainID). As such there is no reason that theyâ€™ll leave it that way.")])]),e._v(" "),a("li",[a("p",[e._v("A minority decide to create an hardfork that the majority disagree with (or simply ignore). Now, the same as above can happen but since we are talking about a minority there is a chance that the majority do not care about the minority. In that case, there would be no incentive for the majority to upgrade the chainID. This means that user of both side of the fork will have the messages meant for the majority chain replayable on the minority-chain (even if this one changed its chainID) unless extra precaution is taken.")])])]),e._v(" "),a("p",[e._v("The solution is to add the blockNumber representing the time at which the message was signed and use it as an argument to the opcode proposed here. This way, when the minority forks with a new chainID, the previous chainID become invalid from that time onward. So new messages destinated to the majority chain can't be replayed on the minority fork.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("EIP-712 is still in draft but would need to be updated to include the blockNumber as part of the values that wallets need to verify for the protection of their users.")]),e._v(" "),a("p",[e._v("Since chainID and blockNumber will vary, they should not be part of the domain separator (meant to be generated once) but another part of the message.")]),e._v(" "),a("p",[e._v("While the pair could be optional for contract that do not care about replays or have other ways to prevent them, if chainID is present, the blockNumber must be present too. And if any of them is present, wallet need to ensure that the chainID is indeed the latest one of the chain being used, while the blockNumber is the latest one at the point of signing. During fork transition, the wallet can use the blockNumber to know which chainID to use.")]),e._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("p",[e._v("This was previously suggested as part of "),a("a",{attrs:{href:"https://ethereum-magicians.org/t/eip-1959-valid-chainid-opcode/3170",target:"_blank",rel:"noopener noreferrer"}},[e._v("EIP1959 discussion"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);